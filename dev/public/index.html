<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Severo.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Severo.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Showcases</span><ul><li><a class="tocitem" href="../pbmc/">Preprocessing and clustering 3k PBMCs</a></li><li><a class="tocitem" href="../performance/">Performance</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Public-Interface"><span>Public Interface</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ExaScience/Severo.jl/blob/master/docs/src/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><p>Documentation for <code>Severo.jl</code>&#39;s public interface.</p><p>See the Internals section of the manual for internal package docs covering all submodules.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation">Public Documentation</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Public-Interface">Public Interface</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Union{LinearEmbedding, AbstractMatrix{T} where T}}"><code>Severo.agreement</code></a></li><li><a href="#Severo.agreement-Tuple{Union{LinearEmbedding, AbstractMatrix{T} where T}, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}"><code>Severo.agreement</code></a></li><li><a href="#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}"><code>Severo.agreement</code></a></li><li><a href="#Severo.alignment-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T"><code>Severo.alignment</code></a></li><li><a href="#Severo.alignment-Union{Tuple{T}, Tuple{AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T"><code>Severo.alignment</code></a></li><li><a href="#Severo.cluster-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}"><code>Severo.cluster</code></a></li><li><a href="#Severo.cluster-Tuple{Random.AbstractRNG, NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}"><code>Severo.cluster</code></a></li><li><a href="#Severo.convert_counts-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}"><code>Severo.convert_counts</code></a></li><li><a href="#Severo.convert_counts-Tuple{AbstractMatrix{T} where T}"><code>Severo.convert_counts</code></a></li><li><a href="#Severo.filter_cells-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_cells</code></a></li><li><a href="#Severo.filter_counts-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_counts</code></a></li><li><a href="#Severo.filter_features-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_features</code></a></li><li><a href="#Severo.filter_rank_markers-Tuple{DataFrames.DataFrame}"><code>Severo.filter_rank_markers</code></a></li><li><a href="#Severo.find_markers-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Real, N, AT, DT}, NamedArrays.NamedVector{var&quot;#s108&quot;, AT, DT} where {var&quot;#s108&quot;&lt;:Integer, AT, DT}}"><code>Severo.find_markers</code></a></li><li><a href="#Severo.find_variable_features"><code>Severo.find_variable_features</code></a></li><li><a href="#Severo.jaccard_index-Union{Tuple{R}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}, Int64}} where R&lt;:AbstractFloat"><code>Severo.jaccard_index</code></a></li><li><a href="#Severo.jaccard_index-Union{Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}}, Tuple{R}} where R&lt;:AbstractFloat"><code>Severo.jaccard_index</code></a></li><li><a href="#Severo.mean_var-Union{Tuple{T}, Tuple{Type{T}, Function, Union{SubArray{Tv, 1, var&quot;#s814&quot;, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false} where {Tv, Ti, var&quot;#s814&quot;&lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}}, SparseArrays.SparseVector}}} where T"><code>Severo.mean_var</code></a></li><li><a href="#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.nearest_neighbours</code></a></li><li><a href="#Severo.nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}"><code>Severo.nearest_neighbours</code></a></li><li><a href="#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.nearest_neighbours</code></a></li><li><a href="#Severo.nearest_neighbours-Tuple{LinearEmbedding, Int64}"><code>Severo.nearest_neighbours</code></a></li><li><a href="#Severo.normalize_cells-Union{Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Severo.normalize_cells</code></a></li><li><a href="#Severo.plot_elbow-Tuple{LinearEmbedding}"><code>Severo.plot_elbow</code></a></li><li><a href="#Severo.plot_embedding-Tuple{LinearEmbedding}"><code>Severo.plot_embedding</code></a></li><li><a href="#Severo.plot_highest_expressed-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.plot_highest_expressed</code></a></li><li><a href="#Severo.plot_loadings-Tuple{LinearEmbedding}"><code>Severo.plot_loadings</code></a></li><li><a href="#Severo.prefilter_markers"><code>Severo.prefilter_markers</code></a></li><li><a href="#Severo.purity-Tuple{AbstractArray{T, N} where {T&lt;:Integer, N}, AbstractArray{T, N} where {T&lt;:Integer, N}}"><code>Severo.purity</code></a></li><li><a href="#Severo.read_10X-Tuple{AbstractString}"><code>Severo.read_10X</code></a></li><li><a href="#Severo.read_10X_h5-Tuple{AbstractString}"><code>Severo.read_10X_h5</code></a></li><li><a href="#Severo.read_csv-Tuple{AbstractString}"><code>Severo.read_csv</code></a></li><li><a href="#Severo.read_data-Tuple{AbstractString}"><code>Severo.read_data</code></a></li><li><a href="#Severo.read_dge-Tuple{AbstractString}"><code>Severo.read_dge</code></a></li><li><a href="#Severo.read_h5-Tuple{AbstractString}"><code>Severo.read_h5</code></a></li><li><a href="#Severo.read_h5ad-Tuple{AbstractString}"><code>Severo.read_h5ad</code></a></li><li><a href="#Severo.read_loom-Tuple{AbstractString}"><code>Severo.read_loom</code></a></li><li><a href="#Severo.scale_features-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T, DT}}"><code>Severo.scale_features</code></a></li><li><a href="#Severo.shared_nearest_neighbours-Tuple{LinearEmbedding, Int64}"><code>Severo.shared_nearest_neighbours</code></a></li><li><a href="#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.shared_nearest_neighbours</code></a></li><li><a href="#Severo.shared_nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}"><code>Severo.shared_nearest_neighbours</code></a></li><li><a href="#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.shared_nearest_neighbours</code></a></li><li><a href="#Severo.umap"><code>Severo.umap</code></a></li><li><a href="#Severo.umap"><code>Severo.umap</code></a></li><li><a href="#Severo.umap-Tuple{AbstractMatrix{T} where T, Int64}"><code>Severo.umap</code></a></li></ul><h2 id="Public-Interface"><a class="docs-heading-anchor" href="#Public-Interface">Public Interface</a><a id="Public-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Union{LinearEmbedding, AbstractMatrix{T} where T}}" href="#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Union{LinearEmbedding, AbstractMatrix{T} where T}}"><code>Severo.agreement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agreement(rng::AbstractRNG, X::AbstractMatrix, Y::Union{AbstractMatrix, LinearEmbedding}; k::Int64)</code></pre><p>A metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.</p><p>This is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator used for k-NN
- `X`: low dimensional embedding for reference dataset
- `Y` low dimensional embedding for transformed dataset
- `k`: number of neighbours to find (default=15)</code></pre><p><strong>Return values</strong>: The agreement score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L46-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}" href="#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}"><code>Severo.agreement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agreement(rng::AbstractRNG, X::Union{AbstractMatrix, LinearEmbedding}, Ys::Union{AbstractMatrix, LinearEmbedding}...; k::Int64)</code></pre><p>A metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.</p><p>This is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator used for k-NN
- `X`: low dimensional embedding for reference dataset
- `Ys` low dimensional embedding for transformed datasets
- `k`: number of neighbours to find (default=15)</code></pre><p><strong>Return values</strong>: The agreement score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L71-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.agreement-Tuple{Union{LinearEmbedding, AbstractMatrix{T} where T}, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}" href="#Severo.agreement-Tuple{Union{LinearEmbedding, AbstractMatrix{T} where T}, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}"><code>Severo.agreement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">agreement(X::Union{AbstractMatrix, LinearEmbedding}, Ys::Union{AbstractMatrix, LinearEmbedding}...; k::Int64)</code></pre><p>A metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.</p><p>This is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: low dimensional embedding for reference dataset
- `Y...`: low dimensional embedding for transformed dataset(s)
- `k`: number of neighbours to find (default=15)</code></pre><p><strong>Return values</strong>: The agreement score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L106-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.alignment-Union{Tuple{T}, Tuple{AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T" href="#Severo.alignment-Union{Tuple{T}, Tuple{AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T"><code>Severo.alignment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alignment(X::AbstractMatrix, datasets::AbstractVector{T}...; k::Union{Nothing,Int64}=nothing) where T</code></pre><p>Calculates the <code>alignment score</code> as defined by Butler 2018 [doi: 10.1038/nbt.4096]. It&#39;s a quantitative metric for the alignment of datasets and calculated as follows:</p><pre><code class="nohighlight hljs">1. Randomly downsample the datasets to have the same number of cells as the smallest dataset
2. Construct a nearest-neighbor graph based on the cells’ embedding in some low dimensional space `X`.
3. For every cell, calculate how many of its k nearest-neighbors belong to the same dataset and average this over all cells.
4. We then normalize by the expected number of same dataset cells and scale to range from 0 to 1.</code></pre><p>If the datasets are well-aligned, we would expect that each cells’ nearest neighbors would be evenly shared across all datasets.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: low dimensional embedding of the aligned datasets
- `datasets`: the split into datasets
- `k`: number of neighbours to find. By default: 1% of the total number of cells, capped by a minimum of 10 and total number of samples drawn</code></pre><p><strong>Return values</strong>: The alignment score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L196-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.alignment-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T" href="#Severo.alignment-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T"><code>Severo.alignment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alignment(rng::AbstractRNG, X::AbstractMatrix, datasets::AbstractVector{T}...; k::Union{Nothing,Int64}=nothing) where T</code></pre><p>Calculates the <code>alignment score</code> as defined by Butler 2018 [doi: 10.1038/nbt.4096]. It&#39;s a quantitative metric for the alignment of datasets and calculated as follows:</p><pre><code class="nohighlight hljs">1. Randomly downsample the datasets to have the same number of cells as the smallest dataset
2. Construct a nearest-neighbor graph based on the cells’ embedding in some low dimensional space `X`.
3. For every cell, calculate how many of its k nearest-neighbors belong to the same dataset and average this over all cells.
4. We then normalize by the expected number of same dataset cells and scale to range from 0 to 1.</code></pre><p>If the datasets are well-aligned, we would expect that each cells’ nearest neighbors would be evenly shared across all datasets.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator used by downsampling and k-NN
- `X`: low dimensional embedding
- `datasets`: the split into datasets
- `k`: number of neighbours to find. By default: 1% of the total number of cells, capped by a minimum of 10 and total number of samples drawn</code></pre><p><strong>Return values</strong>: The alignment score</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L138-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.cluster-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}" href="#Severo.cluster-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}"><code>Severo.cluster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cluster(SNN::NeighbourGraph; algorithm=:louvain, resolution=0.8, nstarts=1, niterations=10) where T</code></pre><p>Cluster cells based on a neighbourhood graph.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `SNN`: shared neighbours graph
- `algorithm`: clustering algorithm to use (louvain)
- `resolution`: parameters above 1 will lead to larger communities whereas below 1 lead to smaller ones
- `nstarts`: number of random starts
- `niterations`: maximum number of iterations per random start
- `group_singletons`: group singletons into nearest cluster, if false keeps singletons</code></pre><p><strong>Return values</strong>:</p><p>cluster assignment per cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/clustering.jl#L20-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.cluster-Tuple{Random.AbstractRNG, NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}" href="#Severo.cluster-Tuple{Random.AbstractRNG, NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T&lt;:Real, DT}}"><code>Severo.cluster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cluster(rng::AbstractRNG, SNN::NeighbourGraph; algorithm=:louvain, resolution=0.8, nstarts=1, niterations=10) where T</code></pre><p>Cluster cells based on a neighbourhood graph.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator
- `SNN`: shared neighbours graph
- `algorithm`: clustering algorithm to use (louvain)
- `resolution`: parameters above 1 will lead to larger communities whereas below 1 lead to smaller ones
- `nstarts`: number of random starts
- `niterations`: maximum number of iterations per random start
- `group_singletons`: group singletons into nearest cluster, if false keeps singletons</code></pre><p><strong>Return values</strong>:</p><p>cluster assignment per cell</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/clustering.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.convert_counts-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}" href="#Severo.convert_counts-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}"><code>Severo.convert_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_counts(X::AbstractMatrix, features::AbstractVector, barcodes::AbstractVector; unique_features::Bool=true)</code></pre><p>Convert a count matrix and labels into its labeled representation</p><p><strong>Arguments</strong>:</p><ul><li><code>X</code>: a count matrix (features x barcodes)</li><li><code>features</code>: list of feature names</li><li><code>barcodes</code>: list of barcodes</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L751-L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.convert_counts-Tuple{AbstractMatrix{T} where T}" href="#Severo.convert_counts-Tuple{AbstractMatrix{T} where T}"><code>Severo.convert_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_counts(X::AbstractMatrix)</code></pre><p>Convert a count matrix into its labeled representation by generating unique labels</p><p><strong>Arguments</strong>:</p><ul><li><code>X</code>: a count matrix (features x barcodes)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L783-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.filter_cells-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}" href="#Severo.filter_cells-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_cells(A::NamedCountMatrix; min_features=0, min_feature_count=0, min_umi=0)</code></pre><p>Filter a labeled count matrix, removing cells for which the metrics fall below the given thresholds</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `A`: the count matrix
- `min_features`: include cells where at least this many features are detected
- `min_features_count`: threshold on the count for which a feature is marked &quot;detected&quot;
- `min_umi`: include cells where the total of umi counts is at least this value</code></pre><p><strong>Return value</strong>:</p><p>The filtered, labeled matrix with cells removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/filtering.jl#L57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.filter_counts-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}" href="#Severo.filter_counts-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_counts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_counts(A::NamedCountMatrix; min_cells=0, min_features=0, min_feature_count=0, min_umi=0)</code></pre><p>Filter a labeled count matrix, removing cells and features for which the metrics fall below the given threshold</p><p>First cells are removed using <code>filter_cells</code> and then features using <code>filter_features</code>. This order can be important!</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `A`: the count matrix
- `min_cells`: include features detected in at least this many cells
- `min_features`: include cells where at least this many features are detected
- `min_features_count`: threshold on the count for which a feature is marked &quot;detected&quot;
- `min_umi`: include cells where the total of umi counts is at least this value</code></pre><p><strong>Return value</strong>:</p><p>The filtered, labeled matrix with cells and features removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/filtering.jl#L79-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.filter_features-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}" href="#Severo.filter_features-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.filter_features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_features(A::NamedCountMatrix; min_cells=0)</code></pre><p>Filter a count matrix, removing features for which the metrics fall below the given thresholds</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `A`: the count matrix
- `min_cells`: include features detected in at least this many cells</code></pre><p><strong>Return value</strong>:</p><p>The filtered matrix with features removed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/filtering.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.filter_rank_markers-Tuple{DataFrames.DataFrame}" href="#Severo.filter_rank_markers-Tuple{DataFrames.DataFrame}"><code>Severo.filter_rank_markers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_rank_markers(de::DataFrame; pval_thresh::Real=1e-2, ngenes::Integer=typemax(Int64))</code></pre><p>Filters and ranks a list of markers (differentially expressed genes).</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`de`: list of markers returned by [find_markers](@ref)
-`pval_thresh`: only keep markers with pval &lt; pval_thresh
-`count`: the number of highest-ranked markers to keep
-`rankby_abs`: rank based on absolute value of the scores</code></pre><p><strong>Return values</strong>:</p><p>A <code>DataFrame</code> containing a ranked list of filtered markers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/diffexpr.jl#L320-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.find_markers-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Real, N, AT, DT}, NamedArrays.NamedVector{var&quot;#s108&quot;, AT, DT} where {var&quot;#s108&quot;&lt;:Integer, AT, DT}}" href="#Severo.find_markers-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Real, N, AT, DT}, NamedArrays.NamedVector{var&quot;#s108&quot;, AT, DT} where {var&quot;#s108&quot;&lt;:Integer, AT, DT}}"><code>Severo.find_markers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{&lt;:Integer};
    method=:wilcoxon, selection::Union{Nothing, NamedArray{Bool, 2}, AbstractArray{Bool,2}}=nothing, log::Bool=false, kw...)</code></pre><p>Finds markers (differentially expressed genes) for each of the classes in a dataset.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`X`: count or data matrix
-`idents`: class identity for each cell
-`method`: Which test to use, supported are: [wilcoxon, t]
-`selection`: a selection of features and groups that should be considered
-`log`: the data is in log-scale (default = false)
-`kw...`: additional parameters passed down to the method</code></pre><p><strong>Return values</strong>:</p><p>A <code>DataFrame</code> containing a list of putative markers with associated statistics (p-values and scores) and log fold-changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/diffexpr.jl#L192-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.find_variable_features" href="#Severo.find_variable_features"><code>Severo.find_variable_features</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_variable_features(counts::NamedCountMatrix, nfeatures=2000; method=:vst, kw...)</code></pre><p>Identification of highly variable features: find features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others).</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`counts`: count matrix
-`nfeatures`: the number of top-ranking features to return
-`method`: how to choose top variable features
-`kw`: additional keyword arguments to pass along to the method</code></pre><p>*Methods**:</p><pre><code class="nohighlight hljs">-`:vst`: fits a line to the log(mean) - log(variance) relationship, then standardizes the features values
    using the observed mean and expected variance. Finally, feature variance is calculated using the standardized values.

    - `loess_span`: span parameter for loess regression when fitting the mean-variance relationship

-`dispersion`: selects the genes with the highest dispersion values

-`meanvarplot`: calculates the feature mean and dispersion, bins the mean according into `num_bins` bins.
    Finally, returns the z-scores for dispersion within each bin.

    - `num_bins`: Total number of bins to use
    - `binning_method`: Specifies how the bins should be computed. Available: `:width` for equal width and `:frequency` for equal frequency binning</code></pre><p><strong>Return value</strong>:</p><p>The <code>nfeatures</code> top-ranked features</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/variablefeatures.jl#L96-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.jaccard_index-Union{Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}}, Tuple{R}} where R&lt;:AbstractFloat" href="#Severo.jaccard_index-Union{Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}}, Tuple{R}} where R&lt;:AbstractFloat"><code>Severo.jaccard_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jaccard_index(X::NamedArray{T,2}; prune::Real=1/15) where T</code></pre><p>Compute a graph with edges defined by the jaccard index. The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `nn`: a nearest neighbour graph
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.jaccard_index-Union{Tuple{R}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}, Int64}} where R&lt;:AbstractFloat" href="#Severo.jaccard_index-Union{Tuple{R}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}, Int64}} where R&lt;:AbstractFloat"><code>Severo.jaccard_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jaccard_index(X::NamedArray{T,2}, k::Int64; prune::Real=1/15) where T</code></pre><p>Compute a graph with edges defined by the jaccard index. The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `nn`: a nearest neighbour graph
- `k`: maximum number of neighbours
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L133-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.mean_var-Union{Tuple{T}, Tuple{Type{T}, Function, Union{SubArray{Tv, 1, var&quot;#s814&quot;, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false} where {Tv, Ti, var&quot;#s814&quot;&lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}}, SparseArrays.SparseVector}}} where T" href="#Severo.mean_var-Union{Tuple{T}, Tuple{Type{T}, Function, Union{SubArray{Tv, 1, var&quot;#s814&quot;, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false} where {Tv, Ti, var&quot;#s814&quot;&lt;:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}}, SparseArrays.SparseVector}}} where T"><code>Severo.mean_var</code></a> — <span class="docstring-category">Method</span></header><section><div><p>variance to mean ratio (VMR) in non-logspace</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/scaling.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.nearest_neighbours-Tuple{LinearEmbedding, Int64}" href="#Severo.nearest_neighbours-Tuple{LinearEmbedding, Int64}"><code>Severo.nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbours(em::LinearEmbedding, k::Int64;
     dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on a linear embedding</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `em`: embedding containing the transformed coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)</code></pre><p><strong>Return values</strong>:</p><p>A k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L229-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}" href="#Severo.nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}"><code>Severo.nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbours(rng::AbstractRNG, em::LinearEmbedding, k::Int64;
     dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on a linear embedding</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator
- `em`: embedding containing the transformed coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)</code></pre><p><strong>Return values</strong>:</p><p>A k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L207-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T" href="#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbours(X::NamedArray{T,2}, k::Int64;
    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on coordinates for each cell.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: a labelled matrix with coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)</code></pre><p><strong>Return values</strong>:</p><p>A k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L183-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T" href="#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbours(rng::AbstractRNG, X::NamedArray{T,2}, k::Int64;
    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on coordinates for each cell.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator
- `X`: a labelled matrix with coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)</code></pre><p><strong>Return values</strong>:</p><p>A k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L157-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.normalize_cells-Union{Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Severo.normalize_cells-Union{Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Severo.normalize_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normalize_cells(X::NamedCountMatrix; method=:lognormalize, scale_factor=1.0)</code></pre><p>Normalize count data with different methods:</p><pre><code class="nohighlight hljs">- `lognormalize`: feature counts are divided by the total count per cell, scaled by `scale_factor` and then log1p transformed.
- `relativecounts`: feature counts are divided by the total count per cell and scaled by `scale_factor`.</code></pre><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: the labelled count matrix to normalize
- `method`: normalization method to apply
- `scale_factor`: the scaling factor
- `dtype`: datatype to be used for the output</code></pre><p><strong>Return values</strong>:</p><p>A labelled data matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/normalize.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.plot_elbow-Tuple{LinearEmbedding}" href="#Severo.plot_elbow-Tuple{LinearEmbedding}"><code>Severo.plot_elbow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_elbow(em::LinearEmbedding)</code></pre><p>Plots the standard deviations of the principle components for easy identification of an elbow in the graph.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`em`: a linear embedding</code></pre><p><strong>Return value</strong>:</p><p>A plot object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/visualization.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.plot_embedding-Tuple{LinearEmbedding}" href="#Severo.plot_embedding-Tuple{LinearEmbedding}"><code>Severo.plot_embedding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_embedding(em::LinearEmbedding)</code></pre><p>Plots the output of a dimensional reduction technique on a 2D scatter plot where each point is a cell and it&#39;s positioned based on the cell embeddings determined by the reduction technique.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`em`: a linear embedding</code></pre><p><strong>Return value</strong>:</p><p>A plot object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/visualization.jl#L75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.plot_highest_expressed-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}" href="#Severo.plot_highest_expressed-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T&lt;:Integer, N, AT, DT}}"><code>Severo.plot_highest_expressed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_highly_expressed_genes(X::NamedCountMatrix, n::Int64; dropfeatures::Union{Nothing, AbstractArray}=nothing)</code></pre><p>Plot the features with the highest average expression across all cells, along with their expression in each individual cell.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`X`: the count matrix
-`n`: the number of the most expressed features to show
-`dropfeatures`: array with names, indices or bits indicating features to drop when plotting</code></pre><p><strong>Return value</strong>:</p><p>A plot object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/visualization.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.plot_loadings-Tuple{LinearEmbedding}" href="#Severo.plot_loadings-Tuple{LinearEmbedding}"><code>Severo.plot_loadings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_loadings(em::LinearEmbedding; dims::AbstractVector{&lt;:Integer}=1:6, nfeatures::Integer=10)</code></pre><p>Visualize top genes associated with reduction components</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`em`: a linear embedding
-`dims`: which components to display
-`nfeatures`: number of genes to display</code></pre><p><strong>Return value</strong>:</p><p>A plot object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/visualization.jl#L47-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.prefilter_markers" href="#Severo.prefilter_markers"><code>Severo.prefilter_markers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prefilter_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{&lt;:Integer};
        logfc_threshold::Real=0.0, min_pct::Real=0.0, min_diff_pct::Real=-Inf, only_pos:Bool=false, log::Bool=false)</code></pre><p>Filter features for each of the classes in a dataset.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">-`X`: count or data matrix
-`idents`: class identity for each cell
-`logfc_threshold`: Limit testing to features which show, on average, at least X-fold difference (log-scale) between the two groups of cells
-`min_pct`: only test features that are detected in a minimum fraction of `min_pct` cells in either of the two populations
-`min_diff_pct`: only test features that show a minimum difference in the fraction of detection between the two groups.
-`only_pos`: only return features with positive log fold-change
-`log`: the data is in log-scale (default = false)</code></pre><p><strong>Return values</strong>:</p><p>Selection matrix for each feature and class</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/diffexpr.jl#L121-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.purity-Tuple{AbstractArray{T, N} where {T&lt;:Integer, N}, AbstractArray{T, N} where {T&lt;:Integer, N}}" href="#Severo.purity-Tuple{AbstractArray{T, N} where {T&lt;:Integer, N}, AbstractArray{T, N} where {T&lt;:Integer, N}}"><code>Severo.purity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">purity(clusters::IntegerArray, classes::IntegerArray)</code></pre><p>Calculates purity between clusters and external clustering (true clusters/classes).</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `clusters`: clustering for which to calculate purity
- `classes`: clustering/classes with which to compare</code></pre><p><strong>Return values</strong>:</p><p>Purity score in the range [0, 1], with a score of 1 representing a pure/accurate clustering</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/metrics.jl#L17-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_10X-Tuple{AbstractString}" href="#Severo.read_10X-Tuple{AbstractString}"><code>Severo.read_10X</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_10X(dirname::AbstractString; unique_features=true)</code></pre><p>Read count matrix from 10X genomics</p><p><strong>Arguments</strong>:</p><ul><li><code>dirname</code>: path to directory containing matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv from 10X</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L611-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_10X_h5-Tuple{AbstractString}" href="#Severo.read_10X_h5-Tuple{AbstractString}"><code>Severo.read_10X_h5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_10X_h5(fname::AbstractString; dataset::AbstractString=&quot;/mm10&quot;, unique_features=true)</code></pre><p>Read count matrix from 10X CellRanger hdf5 file.</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to hdf5 file</li><li><code>dataset</code>: name of dataset to load (default: &quot;mm10&quot;)</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L639-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_csv-Tuple{AbstractString}" href="#Severo.read_csv-Tuple{AbstractString}"><code>Severo.read_csv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_csv(dirname::AbstractString; unique_features=true)</code></pre><p>Read count matrix from CSV</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to csv file</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L573-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_data-Tuple{AbstractString}" href="#Severo.read_data-Tuple{AbstractString}"><code>Severo.read_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_data(path::AbstractString; kw...)</code></pre><p>Tries to identify and read a count matrix in any of the supported formats</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path</li><li><code>kw</code>: additional keyword arguments are passed on</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L711-L724">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_dge-Tuple{AbstractString}" href="#Severo.read_dge-Tuple{AbstractString}"><code>Severo.read_dge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_csv(dirname::AbstractString; unique_features=true)</code></pre><p>Read count matrix from digital gene expression (DGE) files</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to dge file</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L592-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_h5-Tuple{AbstractString}" href="#Severo.read_h5-Tuple{AbstractString}"><code>Severo.read_h5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_h5(fname::AbstractString; dataset::AbstractString=&quot;/mm10&quot;, unique_features=true)</code></pre><p>Read count matrix from hdf5 file.</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to hdf5 file</li><li><code>dataset</code>: name of dataset to load (default: &quot;counts&quot;)</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L671-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_h5ad-Tuple{AbstractString}" href="#Severo.read_h5ad-Tuple{AbstractString}"><code>Severo.read_h5ad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_h5ad(fname::AbstractString, dataset::String=&quot;/mm10&quot;; unique_features=true)</code></pre><p>Read count matrix from hdf5 file as created by AnnData.py. https://anndata.readthedocs.io/en/latest/fileformat-prose.html</p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to hdf5 file</li><li><code>unique_features</code>: should feature names be made unique (default: true)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L691-L705">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.read_loom-Tuple{AbstractString}" href="#Severo.read_loom-Tuple{AbstractString}"><code>Severo.read_loom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_loom(fname::AbstractString; barcode_names::AbstractString=&quot;CellID&quot;, feature_names::AbstractString=&quot;Gene&quot;, unique_names::Bool=true, blocksize::Tuple{Int,Int}=(100,100))</code></pre><p>Read count matrix from <a href="http://linnarssonlab.org/loompy/format/">loom format</a></p><p><strong>Arguments</strong>:</p><ul><li><code>fname</code>: path to loom file</li><li><code>barcode_names</code>: key where the observation/cell names are stored.</li><li><code>feature_names</code>: key where the variable/feature names are stored.</li><li><code>unique_names</code>: should feature and barcode names be made unique (default: true)</li><li><code>blocksize</code>: blocksize to use when reading the matrix (tradeoff between memory and speed)</li></ul><p><strong>Returns values</strong>:</p><p>Returns labeled sparse matrix containing the counts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/input.jl#L545-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.scale_features-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T, DT}}" href="#Severo.scale_features-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T, DT}}"><code>Severo.scale_features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale_features(X::NamedArray{T, 2, SparseMatrixCSC{T, Int64}} ; scale_max=Inf, dtype::Type{&lt;:AbstractFloat})</code></pre><p>Scale and center a count/data matrix along the cells such that each feature is standardized</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: the labelled count/data matrix to scale
- `scale_max`: maximum value of the scaled data</code></pre><p><strong>Return values</strong>:</p><p>A centered matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/scaling.jl#L321-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.shared_nearest_neighbours-Tuple{LinearEmbedding, Int64}" href="#Severo.shared_nearest_neighbours-Tuple{LinearEmbedding, Int64}"><code>Severo.shared_nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shared_nearest_neighbours(em::LinearEmbedding, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2))</code></pre><p>Compute a k-nearest neighbours graph based on an embedding of cells and its Jaccard index.<br/>The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `em`: embedding containing the transformed coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L328-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.shared_nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}" href="#Severo.shared_nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}"><code>Severo.shared_nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shared_nearest_neighbours(rng::AbstractRNG, em::LinearEmbedding, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2))</code></pre><p>Compute a k-nearest neighbours graph based on an embedding of cells and its Jaccard index.<br/>The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator
- `em`: embedding containing the transformed coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L280-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T" href="#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.shared_nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shared_nearest_neighbours(X::NamedArray{T,2}, k::Int64;
    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on coordinates for each cell and its Jaccard index.<br/>The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: a labelled matrix with coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L304-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T" href="#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T"><code>Severo.shared_nearest_neighbours</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shared_nearest_neighbours(rng::AbstractRNG, X::NamedArray{T,2}, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T</code></pre><p>Compute a k-nearest neighbours graph based on coordinates for each cell and its Jaccard index.<br/>The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. &quot;0&quot; indicating no overlap and &quot;1&quot; indicating full overlap.</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `rng`: random number generator
- `X`: a labelled matrix with coordinates for each cell
- `k`: number of nearest neighbours to find
- `dims`: which dimensions to use
- `include_self`: include the cell in its k-nearest neighbours
- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)
- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph</code></pre><p><strong>Return values</strong>:</p><p>A shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/neighbours.jl#L250-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.umap" href="#Severo.umap"><code>Severo.umap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">umap(X::NamedMatrix, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T</code></pre><p>Performs a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates.</p><p>For a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: a labelled matrix with coordinates for each cell
- `ncomponents`: the dimensionality of the embedding
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.
- `min_dist`: controls how tightly the embedding is allowed compress points together.
- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding
- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)</code></pre><p><strong>Return values</strong>:</p><p>A low-dimensional embedding of the cells</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/embedding.jl#L169-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.umap" href="#Severo.umap"><code>Severo.umap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">umap(em::LinearEmbedding, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T</code></pre><p>Performs a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates in the linear embedding.</p><p>For a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `em`: embedding containing the transformed coordinates for each cell
- `ncomponents`: the dimensionality of the embedding
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.
- `min_dist`: controls how tightly the embedding is allowed compress points together.
- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding
- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)</code></pre><p><strong>Return values</strong>:</p><p>A low-dimensional embedding of the cells</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/embedding.jl#L145-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Severo.umap-Tuple{AbstractMatrix{T} where T, Int64}" href="#Severo.umap-Tuple{AbstractMatrix{T} where T, Int64}"><code>Severo.umap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">umap(X::AbstractMatrix, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T</code></pre><p>Performs a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates in the linear embedding.</p><p>For a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]</p><p><strong>Arguments</strong>:</p><pre><code class="nohighlight hljs">- `X`: an unlabelled matrix with coordinates for each cell
- `ncomponents`: the dimensionality of the embedding
- `dims`: which dimensions to use
- `metric`: distance metric to use
- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.
- `min_dist`: controls how tightly the embedding is allowed compress points together.
- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding
- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)</code></pre><p><strong>Return values</strong>:</p><p>A low-dimensional embedding of the cells</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ExaScience/Severo.jl/blob/a9b85bd387a2e105fc6091a5b06ee74142a17ed0/src/embedding.jl#L121-L142">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../performance/">« Performance</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Friday 1 October 2021 14:42">Friday 1 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
