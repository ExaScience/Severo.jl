var documenterSearchIndex = {"docs":
[{"location":"pbmc/#Preprocessing-and-clustering-3k-PBMCs","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"This showcase reproduces Seurat's Guided Clustering Tutorial","category":"page"},{"location":"pbmc/#Overview","page":"Preprocessing and clustering 3k PBMCs","title":"Overview","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Pages = [\"pbmc.md\"]","category":"page"},{"location":"pbmc/#Loading-data","page":"Preprocessing and clustering 3k PBMCs","title":"Loading data","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"The data consists of 3k PBMCs from a Healthy Donor and is freely available from 10x Genomics.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"You can either download the data manually","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"mkdir pbmc3k\nwget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz -O pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\ncd pbmc3k; tar -xzf pbmc3k_filtered_gene_bc_matrices.tar.gz --strip-components 2","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"The read_10X function reads the data from the cellranger 10X pipeline and returns a labelled count matrix. Each entry indicated the number of molecules detected for each feature/gene (columns) and each cell (rows).","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"using Severo\nX = read_10X(\"pbmc3k/\")","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"warning: Warning\nThe meaning of the rows and columns is different from the representation used by other packages like Seurat","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Alternatively, the dataset function can be used to load a dataset from a predefined collection. For example, the PBMC collection is known by Cell.jl and can be easily loaded as follows:","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"using Severo\nX = dataset(\"PBMC\", \"3k\")\n\n# The matrix can be indexed using names or indices. For instance,\n# we can look at specific genes in the first thirty cells\n#X[1:30, [\"CD3D\", \"TCL1A\", \"MS4A1\"]]","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"The count data is stored in a sparse matrix format, only storing non-zero elements of the matrix. Any values not shown are zero.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"read_data\nread_10X\ndataset","category":"page"},{"location":"pbmc/#Severo.read_data","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.read_data","text":"read_data(path::AbstractString; kw...)\n\nTries to identify and read a count matrix in any of the supported formats\n\nArguments:\n\nfname: path\nkw: additional keyword arguments are passed on\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.read_10X","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.read_10X","text":"read_10X(dirname::AbstractString; unique_features=true)\n\nRead count matrix from 10X genomics\n\nArguments:\n\ndirname: path to directory containing matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv from 10X\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Preprocessing","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"using Plots\nusing StatsPlots\npyplot() # hide\nplot_highest_expressed(X)\nsavefig(\"he-plot.svg\"); nothing # hide","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"(Image: )","category":"page"},{"location":"pbmc/#Filtering","page":"Preprocessing and clustering 3k PBMCs","title":"Filtering","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Two filtering function are available for filtering cells and features/genes based on basic criteria such as the number of features detected, the number of cells for which a feature is detected and the total number of counts.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"X = filter_cells(X, min_features=200)\nX = filter_features(X, min_cells=3)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"This filters out cells with less than 200 features/genes and features detected in less than 3 cells. For convenience, filter_counts combines these two into a single function, similar to Seurat. Beware that the order in which you call these functions can matter.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"filter_features\nfilter_cells\nfilter_counts","category":"page"},{"location":"pbmc/#Severo.filter_features","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.filter_features","text":"filter_features(; min_cells = 0)\n\nPartial version of filterfeatures(A::NamedCountMatrix; mincells = 0)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.filter_cells","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.filter_cells","text":"filter_cells(; min_features = 0, min_feature_count = 0, min_umi = 0)\n\nPartial version of filtercells(A::NamedCountMatrix; minfeatures = 0, minfeaturecount = 0, min_umi = 0)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.filter_counts","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.filter_counts","text":"filter_counts(; min_cells = 0, min_features = 0, min_feature_count = 0, min_umi = 0)\n\nPartial version of filtercounts(A::NamedCountMatrix; mincells = 0, minfeatures = 0, minfeaturecount = 0, minumi = 0)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Normalization","page":"Preprocessing and clustering 3k PBMCs","title":"Normalization","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"After removing unwanted cells from the dataset, the next step is to normalize the data. The basic method normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor and optionally log-transforming the result.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Y = normalize_cells(X, method=:lognormalize, scale_factor=1e4)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"normalize_cells","category":"page"},{"location":"pbmc/#Severo.normalize_cells","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.normalize_cells","text":"normalize_cells(; method = :lognormalize, scale_factor::Real = 1.0, dtype::Type{T} = Float64) where T <: AbstractFloat\n\nPartial version of normalizecells(X::NamedCountMatrix; method = :lognormalize, scalefactor::Real = 1.0, dtype::Type{T} = Float64) where T <: AbstractFloat\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Identifying-highly-variable-features","page":"Preprocessing and clustering 3k PBMCs","title":"Identifying highly variable features","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Next, we select a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others).","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"hvf = find_variable_features(X, 2000; method=:vst)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"find_variable_features","category":"page"},{"location":"pbmc/#Severo.find_variable_features","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.find_variable_features","text":"find_variable_features(nfeatures = 2000; method = :vst, dtype::Type{<:AbstractFloat} = Float64, kw...)\n\nPartial version of findvariablefeatures(counts::NamedCountMatrix, nfeatures = 2000; method = :vst, dtype::Type{<:AbstractFloat} = Float64, kw...)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Dimensionality-reduction","page":"Preprocessing and clustering 3k PBMCs","title":"Dimensionality reduction","text":"","category":"section"},{"location":"pbmc/#Scaling","page":"Preprocessing and clustering 3k PBMCs","title":"Scaling","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Prior to dimensional reduction techniques like PCA, it's a good idea to scale_features the data. Scaling performs two basic operations:","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Shifts the expression of each gene, so that the mean expression across cells is 0\nScales the expression of each gene, so that the standard deviation across cells is 1. This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate\nClips values exceeding standard deviation of scale_max","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Y = Y[:,hvf] # only use highly-variable features\nS = scale_features(Y; scale_max=10)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"scale_features","category":"page"},{"location":"pbmc/#Severo.scale_features","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.scale_features","text":"scale_features(; scale_max::Real = Inf, dtype::Type{<:AbstractFloat} = Float64, features::Union{Nothing, AbstractArray} = nothing)\n\nPartial version of scalefeatures(X::(NamedArray{T, 2, SparseMatrixCSC{T, Int64}} where T); scalemax::Real = Inf, dtype::Type{<:AbstractFloat} = Float64, features::Union{Nothing, AbstractArray} = nothing)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Principal-component-analysis","page":"Preprocessing and clustering 3k PBMCs","title":"Principal component analysis","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Reduce the dimensionality of the data by running principal component analysis (PCA), which reveals the main axes of variation and de-noises the data.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"em = embedding(S, 15, method=:pca)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"plot_elbow(em)\nsavefig(\"elbow-plot.svg\"); nothing # hide","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"(Image: )","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"embedding","category":"page"},{"location":"pbmc/#Severo.embedding","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.embedding","text":"embedding(ncomponents::Int64 = 50; method = :pca, kw...)\n\nPartial version of embedding(X, ncomponents::Int64 = 50; method = :pca, kw...)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Clustering-the-cells","page":"Preprocessing and clustering 3k PBMCs","title":"Clustering the cells","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Briefly, the clustering embed cells in a graph structure with edges between cells with similar feature expression patterns, and then attempt to partition this graph into highly interconnected 'quasi-cliques' or 'communities'.","category":"page"},{"location":"pbmc/#Computing-the-neighborhood-graph","page":"Preprocessing and clustering 3k PBMCs","title":"Computing the neighborhood graph","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"First, we need to find the k-nearest neighbors of all the cells based on the euclidean distance in PCA space, and then compute a graph based on the shared overlap in the local neighborhoods between any two cells (Jaccard similarity). These step are performed using the nearest_neighbours and jaccard_index functions. For convenience, the two steps are also combined in the shared_nearest_neighours function.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"nn = nearest_neighbours(em, 20, dims=1:10)\nsnn = jaccard_index(nn, prune=1/15)\n# or as a single step\n#snn = nearest_neighbours(em, 20, dims=1:10, prune=1/15)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"nearest_neighbours\njaccard_index\nshared_nearest_neighbours","category":"page"},{"location":"pbmc/#Severo.nearest_neighbours","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.nearest_neighbours","text":"nearest_neighbours(k::Int64; dims = (:), metric::SemiMetric = Euclidean(), include_self::Bool = true, ntables::Int64 = 2 * size(X, 2)) where T\n\nPartial version of nearestneighbours(X::NamedArray{T, 2}, k::Int64; dims = (:), metric::SemiMetric = Euclidean(), includeself::Bool = true, ntables::Int64 = 2 * size(X, 2)) where T\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.jaccard_index","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.jaccard_index","text":"jaccard_index(k::Int64; prune::Real = 1 / 15, dtype::Type{R} = Float64) where R <: AbstractFloat\n\nPartial version of jaccard_index(nn::(NamedArray{T, 2} where T), k::Int64; prune::Real = 1 / 15, dtype::Type{R} = Float64) where R <: AbstractFloat\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.shared_nearest_neighbours","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.shared_nearest_neighbours","text":"shared_nearest_neighbours(k::Int64; kw...) where T\n\nPartial version of sharednearestneighbours(X::NamedArray{T, 2}, k::Int64; kw...) where T\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Clustering-the-neighborhood-graph","page":"Preprocessing and clustering 3k PBMCs","title":"Clustering the neighborhood graph","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Clustering is performed using a graph-based method called Louvain clustering which tries to detect communities based on optimizing a modularity function. Since this is a greedy algorithm, which can get stuck in local minima based on random initialization, multiple restarts are required to find a more \"global\" minima.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"lbls = cluster(snn)","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"cluster","category":"page"},{"location":"pbmc/#Severo.cluster","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.cluster","text":"cluster(; kw...)\n\nPartial version of cluster(SNN::NeighbourGraph; kw...)\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Finding-differentially-expressed-features","page":"Preprocessing and clustering 3k PBMCs","title":"Finding differentially expressed features","text":"","category":"section"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"We can find markers that define clusters via differential expression. It identifies positive and negative markers for a single cluster compared to the other cells. find_markers performs this process for every cluster. The function returns a DataFrame containing for each marker: the p-value, the log-foldchange and statistical score.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"dx = find_markers(X, lbls; method=:wilcoxon)\ndx = filter_rank_markers(dx)\ndx[1:10, :]","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"Performance can be improved by first filtering the features based on the percentage of cells and the fold-change between the groups.","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"# filtering and DE on the lognormalized data\nsel = prefilter_markers(Y, lbls, logfc_threshold=0.25, min_pct=0.1, log=true, only_pos=true)\ndx = find_markers(Y, lbls; method=:t, log=true, selection=sel) # t-test\ndx = filter_rank_markers(dx)\ndx[1:10, :]","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"find_markers\nfilter_rank_markers\nprefilter_markers","category":"page"},{"location":"pbmc/#Severo.find_markers","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.find_markers","text":"find_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{<:Integer};\n    method=:wilcoxon, selection::Union{Nothing, NamedArray{Bool, 2}, AbstractArray{Bool,2}}=nothing, log::Bool=false, kw...)\n\nFinds markers (differentially expressed genes) for each of the classes in a dataset.\n\nArguments:\n\n-`X`: count or data matrix\n-`idents`: class identity for each cell\n-`method`: Which test to use, supported are: [wilcoxon, t]\n-`selection`: a selection of features and groups that should be considered\n-`log`: the data is in log-scale (default = false)\n-`kw...`: additional parameters passed down to the method\n\nReturn values:\n\nA DataFrame containing a list of putative markers with associated statistics (p-values and scores) and log fold-changes.\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.filter_rank_markers","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.filter_rank_markers","text":"filter_rank_markers(de::DataFrame; pval_thresh::Real=1e-2, ngenes::Integer=typemax(Int64))\n\nFilters and ranks a list of markers (differentially expressed genes).\n\nArguments:\n\n-`de`: list of markers returned by [find_markers](@ref)\n-`pval_thresh`: only keep markers with pval < pval_thresh\n-`count`: the number of highest-ranked markers to keep\n-`rankby_abs`: rank based on absolute value of the scores\n\nReturn values:\n\nA DataFrame containing a ranked list of filtered markers.\n\n\n\n\n\n","category":"function"},{"location":"pbmc/#Severo.prefilter_markers","page":"Preprocessing and clustering 3k PBMCs","title":"Severo.prefilter_markers","text":"prefilter_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{<:Integer};\n        logfc_threshold::Real=0.0, min_pct::Real=0.0, min_diff_pct::Real=-Inf, only_pos:Bool=false, log::Bool=false)\n\nFilter features for each of the classes in a dataset.\n\nArguments:\n\n-`X`: count or data matrix\n-`idents`: class identity for each cell\n-`logfc_threshold`: Limit testing to features which show, on average, at least X-fold difference (log-scale) between the two groups of cells\n-`min_pct`: only test features that are detected in a minimum fraction of `min_pct` cells in either of the two populations\n-`min_diff_pct`: only test features that show a minimum difference in the fraction of detection between the two groups.\n-`only_pos`: only return features with positive log fold-change\n-`log`: the data is in log-scale (default = false)\n\nReturn values:\n\nSelection matrix for each feature and class\n\n\n\n\n\n","category":"function"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"plot_violin(X, [\"CST3\", \"NKG7\", \"PPBP\", \"S100A4\"], lbls)\nsavefig(\"violin-plot.svg\"); nothing # hide","category":"page"},{"location":"pbmc/","page":"Preprocessing and clustering 3k PBMCs","title":"Preprocessing and clustering 3k PBMCs","text":"(Image: )","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/#PBMC-3K","page":"Performance","title":"PBMC 3K","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Function Severo.jl Seurat Speedup\nfilter_counts 0.066542 0.434 6.71x\nnormalize 0.06 0.212 3.53x\nhighly_var.. 0.362585 1.114 3.07x\nscale(hvf) 0.020628 2.66 128x\npca 0.123401 6.54 52.9x","category":"page"},{"location":"performance/#.3M-brain-cells-(10X)","page":"Performance","title":"1.3M brain cells (10X)","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"Function Severo.jl Seurat Speedup\nfilter_counts 74.04964 1490.6 20x\nnormalize 72.24885 1844.9 25x\nhighly_var.. 36.32924 2716.39 75x\nscale(hvf) 6.894031 19086.6 2800x\npca 70.62987 27290.0 390x\nshared_nn 947.86579 2872.46 3x\ncluster 819.51106 9976.62 12x\nde 3835.9645 6 days x","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Documentation for Severo.jl's public interface.","category":"page"},{"location":"public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"public/","page":"Public","title":"Public","text":"Modules = [Severo]\nOrder   = [:function, :type]","category":"page"},{"location":"public/#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Union{LinearEmbedding, AbstractMatrix{T} where T}}","page":"Public","title":"Severo.agreement","text":"agreement(rng::AbstractRNG, X::AbstractMatrix, Y::Union{AbstractMatrix, LinearEmbedding}; k::Int64)\n\nA metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.\n\nThis is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.\n\nArguments:\n\n- `rng`: random number generator used for k-NN\n- `X`: low dimensional embedding for reference dataset\n- `Y` low dimensional embedding for transformed dataset\n- `k`: number of neighbours to find (default=15)\n\nReturn values: The agreement score\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.agreement-Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}","page":"Public","title":"Severo.agreement","text":"agreement(rng::AbstractRNG, X::Union{AbstractMatrix, LinearEmbedding}, Ys::Union{AbstractMatrix, LinearEmbedding}...; k::Int64)\n\nA metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.\n\nThis is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.\n\nArguments:\n\n- `rng`: random number generator used for k-NN\n- `X`: low dimensional embedding for reference dataset\n- `Ys` low dimensional embedding for transformed datasets\n- `k`: number of neighbours to find (default=15)\n\nReturn values: The agreement score\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.agreement-Tuple{Union{LinearEmbedding, AbstractMatrix{T} where T}, Vararg{Union{LinearEmbedding, AbstractMatrix{T} where T}, N} where N}","page":"Public","title":"Severo.agreement","text":"agreement(X::Union{AbstractMatrix, LinearEmbedding}, Ys::Union{AbstractMatrix, LinearEmbedding}...; k::Int64)\n\nA metric for quantifying how much a transformation/factorization distorts the geometry of the original dataset. The greater the agreement, the less distortion of geometry there is.\n\nThis is calculated by performing dimensionality reduction on the original and transformed dataset, and measuring similarity between the k nearest neighbors for each cell in the datasets. The Jaccard index is used to quantify similarity, and is the final metric averages across all cells.\n\nArguments:\n\n- `X`: low dimensional embedding for reference dataset\n- `Y...`: low dimensional embedding for transformed dataset(s)\n- `k`: number of neighbours to find (default=15)\n\nReturn values: The agreement score\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.alignment-Union{Tuple{T}, Tuple{AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T","page":"Public","title":"Severo.alignment","text":"alignment(X::AbstractMatrix, datasets::AbstractVector{T}...; k::Union{Nothing,Int64}=nothing) where T\n\nCalculates the alignment score as defined by Butler 2018 [doi: 10.1038/nbt.4096]. It's a quantitative metric for the alignment of datasets and calculated as follows:\n\n1. Randomly downsample the datasets to have the same number of cells as the smallest dataset\n2. Construct a nearest-neighbor graph based on the cells’ embedding in some low dimensional space `X`.\n3. For every cell, calculate how many of its k nearest-neighbors belong to the same dataset and average this over all cells.\n4. We then normalize by the expected number of same dataset cells and scale to range from 0 to 1.\n\nIf the datasets are well-aligned, we would expect that each cells’ nearest neighbors would be evenly shared across all datasets.\n\nArguments:\n\n- `X`: low dimensional embedding of the aligned datasets\n- `datasets`: the split into datasets\n- `k`: number of neighbours to find. By default: 1% of the total number of cells, capped by a minimum of 10 and total number of samples drawn\n\nReturn values: The alignment score\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.alignment-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractMatrix{T} where T, Vararg{AbstractVector{T}, N} where N}} where T","page":"Public","title":"Severo.alignment","text":"alignment(rng::AbstractRNG, X::AbstractMatrix, datasets::AbstractVector{T}...; k::Union{Nothing,Int64}=nothing) where T\n\nCalculates the alignment score as defined by Butler 2018 [doi: 10.1038/nbt.4096]. It's a quantitative metric for the alignment of datasets and calculated as follows:\n\n1. Randomly downsample the datasets to have the same number of cells as the smallest dataset\n2. Construct a nearest-neighbor graph based on the cells’ embedding in some low dimensional space `X`.\n3. For every cell, calculate how many of its k nearest-neighbors belong to the same dataset and average this over all cells.\n4. We then normalize by the expected number of same dataset cells and scale to range from 0 to 1.\n\nIf the datasets are well-aligned, we would expect that each cells’ nearest neighbors would be evenly shared across all datasets.\n\nArguments:\n\n- `rng`: random number generator used by downsampling and k-NN\n- `X`: low dimensional embedding\n- `datasets`: the split into datasets\n- `k`: number of neighbours to find. By default: 1% of the total number of cells, capped by a minimum of 10 and total number of samples drawn\n\nReturn values: The alignment score\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.cluster-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T<:Real, DT}}","page":"Public","title":"Severo.cluster","text":"cluster(SNN::NeighbourGraph; algorithm=:louvain, resolution=0.8, nstarts=1, niterations=10) where T\n\nCluster cells based on a neighbourhood graph.\n\nArguments:\n\n- `SNN`: shared neighbours graph\n- `algorithm`: clustering algorithm to use (louvain)\n- `resolution`: parameters above 1 will lead to larger communities whereas below 1 lead to smaller ones\n- `nstarts`: number of random starts\n- `niterations`: maximum number of iterations per random start\n- `group_singletons`: group singletons into nearest cluster, if false keeps singletons\n\nReturn values:\n\ncluster assignment per cell\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.cluster-Tuple{Random.AbstractRNG, NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T<:Real, DT}}","page":"Public","title":"Severo.cluster","text":"cluster(rng::AbstractRNG, SNN::NeighbourGraph; algorithm=:louvain, resolution=0.8, nstarts=1, niterations=10) where T\n\nCluster cells based on a neighbourhood graph.\n\nArguments:\n\n- `rng`: random number generator\n- `SNN`: shared neighbours graph\n- `algorithm`: clustering algorithm to use (louvain)\n- `resolution`: parameters above 1 will lead to larger communities whereas below 1 lead to smaller ones\n- `nstarts`: number of random starts\n- `niterations`: maximum number of iterations per random start\n- `group_singletons`: group singletons into nearest cluster, if false keeps singletons\n\nReturn values:\n\ncluster assignment per cell\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.convert_counts-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"Public","title":"Severo.convert_counts","text":"convert_counts(X::AbstractMatrix, features::AbstractVector, barcodes::AbstractVector; unique_features::Bool=true)\n\nConvert a count matrix and labels into its labeled representation\n\nArguments:\n\nX: a count matrix (features x barcodes)\nfeatures: list of feature names\nbarcodes: list of barcodes\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.convert_counts-Tuple{AbstractMatrix{T} where T}","page":"Public","title":"Severo.convert_counts","text":"convert_counts(X::AbstractMatrix)\n\nConvert a count matrix into its labeled representation by generating unique labels\n\nArguments:\n\nX: a count matrix (features x barcodes)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.filter_cells-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Integer, N, AT, DT}}","page":"Public","title":"Severo.filter_cells","text":"filter_cells(A::NamedCountMatrix; min_features=0, min_feature_count=0, min_umi=0)\n\nFilter a labeled count matrix, removing cells for which the metrics fall below the given thresholds\n\nArguments:\n\n- `A`: the count matrix\n- `min_features`: include cells where at least this many features are detected\n- `min_features_count`: threshold on the count for which a feature is marked \"detected\"\n- `min_umi`: include cells where the total of umi counts is at least this value\n\nReturn value:\n\nThe filtered, labeled matrix with cells removed\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.filter_counts-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Integer, N, AT, DT}}","page":"Public","title":"Severo.filter_counts","text":"filter_counts(A::NamedCountMatrix; min_cells=0, min_features=0, min_feature_count=0, min_umi=0)\n\nFilter a labeled count matrix, removing cells and features for which the metrics fall below the given threshold\n\nFirst cells are removed using filter_cells and then features using filter_features. This order can be important!\n\nArguments:\n\n- `A`: the count matrix\n- `min_cells`: include features detected in at least this many cells\n- `min_features`: include cells where at least this many features are detected\n- `min_features_count`: threshold on the count for which a feature is marked \"detected\"\n- `min_umi`: include cells where the total of umi counts is at least this value\n\nReturn value:\n\nThe filtered, labeled matrix with cells and features removed\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.filter_features-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Integer, N, AT, DT}}","page":"Public","title":"Severo.filter_features","text":"filter_features(A::NamedCountMatrix; min_cells=0)\n\nFilter a count matrix, removing features for which the metrics fall below the given thresholds\n\nArguments:\n\n- `A`: the count matrix\n- `min_cells`: include features detected in at least this many cells\n\nReturn value:\n\nThe filtered matrix with features removed\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.filter_rank_markers-Tuple{DataFrames.DataFrame}","page":"Public","title":"Severo.filter_rank_markers","text":"filter_rank_markers(de::DataFrame; pval_thresh::Real=1e-2, ngenes::Integer=typemax(Int64))\n\nFilters and ranks a list of markers (differentially expressed genes).\n\nArguments:\n\n-`de`: list of markers returned by [find_markers](@ref)\n-`pval_thresh`: only keep markers with pval < pval_thresh\n-`count`: the number of highest-ranked markers to keep\n-`rankby_abs`: rank based on absolute value of the scores\n\nReturn values:\n\nA DataFrame containing a ranked list of filtered markers.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.find_markers-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Real, N, AT, DT}, NamedArrays.NamedVector{var\"#s110\", AT, DT} where {var\"#s110\"<:Integer, AT, DT}}","page":"Public","title":"Severo.find_markers","text":"find_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{<:Integer};\n    method=:wilcoxon, selection::Union{Nothing, NamedArray{Bool, 2}, AbstractArray{Bool,2}}=nothing, log::Bool=false, kw...)\n\nFinds markers (differentially expressed genes) for each of the classes in a dataset.\n\nArguments:\n\n-`X`: count or data matrix\n-`idents`: class identity for each cell\n-`method`: Which test to use, supported are: [wilcoxon, t]\n-`selection`: a selection of features and groups that should be considered\n-`log`: the data is in log-scale (default = false)\n-`kw...`: additional parameters passed down to the method\n\nReturn values:\n\nA DataFrame containing a list of putative markers with associated statistics (p-values and scores) and log fold-changes.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.find_variable_features","page":"Public","title":"Severo.find_variable_features","text":"find_variable_features(counts::NamedCountMatrix, nfeatures=2000; method=:vst, kw...)\n\nIdentification of highly variable features: find features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others).\n\nArguments:\n\n-`counts`: count matrix\n-`nfeatures`: the number of top-ranking features to return\n-`method`: how to choose top variable features\n-`kw`: additional keyword arguments to pass along to the method\n\n*Methods**:\n\n-`:vst`: fits a line to the log(mean) - log(variance) relationship, then standardizes the features values\n    using the observed mean and expected variance. Finally, feature variance is calculated using the standardized values.\n\n    - `loess_span`: span parameter for loess regression when fitting the mean-variance relationship\n\n-`dispersion`: selects the genes with the highest dispersion values\n\n-`meanvarplot`: calculates the feature mean and dispersion, bins the mean according into `num_bins` bins.\n    Finally, returns the z-scores for dispersion within each bin.\n\n    - `num_bins`: Total number of bins to use\n    - `binning_method`: Specifies how the bins should be computed. Available: `:width` for equal width and `:frequency` for equal frequency binning\n\nReturn value:\n\nThe nfeatures top-ranked features\n\n\n\n\n\n","category":"function"},{"location":"public/#Severo.jaccard_index-Union{Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}}, Tuple{R}} where R<:AbstractFloat","page":"Public","title":"Severo.jaccard_index","text":"jaccard_index(X::NamedArray{T,2}; prune::Real=1/15) where T\n\nCompute a graph with edges defined by the jaccard index. The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `nn`: a nearest neighbour graph\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.jaccard_index-Union{Tuple{R}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {T, AT, DT}, Int64}} where R<:AbstractFloat","page":"Public","title":"Severo.jaccard_index","text":"jaccard_index(X::NamedArray{T,2}, k::Int64; prune::Real=1/15) where T\n\nCompute a graph with edges defined by the jaccard index. The Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `nn`: a nearest neighbour graph\n- `k`: maximum number of neighbours\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.mean_var-Union{Tuple{T}, Tuple{Type{T}, Function, Union{SubArray{Tv, 1, var\"#s814\", Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, false} where {Tv, Ti, var\"#s814\"<:SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}}, SparseArrays.SparseVector}}} where T","page":"Public","title":"Severo.mean_var","text":"variance to mean ratio (VMR) in non-logspace\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.nearest_neighbours-Tuple{LinearEmbedding, Int64}","page":"Public","title":"Severo.nearest_neighbours","text":"nearest_neighbours(em::LinearEmbedding, k::Int64;\n     dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on a linear embedding\n\nArguments:\n\n- `em`: embedding containing the transformed coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n\nReturn values:\n\nA k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}","page":"Public","title":"Severo.nearest_neighbours","text":"nearest_neighbours(rng::AbstractRNG, em::LinearEmbedding, k::Int64;\n     dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on a linear embedding\n\nArguments:\n\n- `rng`: random number generator\n- `em`: embedding containing the transformed coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n\nReturn values:\n\nA k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T","page":"Public","title":"Severo.nearest_neighbours","text":"nearest_neighbours(X::NamedArray{T,2}, k::Int64;\n    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on coordinates for each cell.\n\nArguments:\n\n- `X`: a labelled matrix with coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n\nReturn values:\n\nA k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T","page":"Public","title":"Severo.nearest_neighbours","text":"nearest_neighbours(rng::AbstractRNG, X::NamedArray{T,2}, k::Int64;\n    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on coordinates for each cell.\n\nArguments:\n\n- `rng`: random number generator\n- `X`: a labelled matrix with coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n\nReturn values:\n\nA k-nearest neighbours graph represented by a sparse matrix. k-neighbours are stored as rows for each cell (cols)\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.normalize_cells-Union{Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Integer, N, AT, DT}}, Tuple{T}} where T<:AbstractFloat","page":"Public","title":"Severo.normalize_cells","text":"normalize_cells(X::NamedCountMatrix; method=:lognormalize, scale_factor=1.0)\n\nNormalize count data with different methods:\n\n- `lognormalize`: feature counts are divided by the total count per cell, scaled by `scale_factor` and then log1p transformed.\n- `relativecounts`: feature counts are divided by the total count per cell and scaled by `scale_factor`.\n\nArguments:\n\n- `X`: the labelled count matrix to normalize\n- `method`: normalization method to apply\n- `scale_factor`: the scaling factor\n- `dtype`: datatype to be used for the output\n\nReturn values:\n\nA labelled data matrix\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.plot_elbow-Tuple{LinearEmbedding}","page":"Public","title":"Severo.plot_elbow","text":"plot_elbow(em::LinearEmbedding)\n\nPlots the standard deviations of the principle components for easy identification of an elbow in the graph.\n\nArguments:\n\n-`em`: a linear embedding\n\nReturn value:\n\nA plot object\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.plot_embedding-Tuple{LinearEmbedding}","page":"Public","title":"Severo.plot_embedding","text":"plot_embedding(em::LinearEmbedding)\n\nPlots the output of a dimensional reduction technique on a 2D scatter plot where each point is a cell and it's positioned based on the cell embeddings determined by the reduction technique.\n\nArguments:\n\n-`em`: a linear embedding\n\nReturn value:\n\nA plot object\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.plot_highest_expressed-Tuple{NamedArrays.NamedArray{T, N, AT, DT} where {T<:Integer, N, AT, DT}}","page":"Public","title":"Severo.plot_highest_expressed","text":"plot_highly_expressed_genes(X::NamedCountMatrix, n::Int64; dropfeatures::Union{Nothing, AbstractArray}=nothing)\n\nPlot the features with the highest average expression across all cells, along with their expression in each individual cell.\n\nArguments:\n\n-`X`: the count matrix\n-`n`: the number of the most expressed features to show\n-`dropfeatures`: array with names, indices or bits indicating features to drop when plotting\n\nReturn value:\n\nA plot object\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.plot_loadings-Tuple{LinearEmbedding}","page":"Public","title":"Severo.plot_loadings","text":"plot_loadings(em::LinearEmbedding; dims::AbstractVector{<:Integer}=1:6, nfeatures::Integer=10)\n\nVisualize top genes associated with reduction components\n\nArguments:\n\n-`em`: a linear embedding\n-`dims`: which components to display\n-`nfeatures`: number of genes to display\n\nReturn value:\n\nA plot object\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.prefilter_markers","page":"Public","title":"Severo.prefilter_markers","text":"prefilter_markers(X::Union{NamedCountMatrix, NamedDataMatrix}, idents::NamedVector{<:Integer};\n        logfc_threshold::Real=0.0, min_pct::Real=0.0, min_diff_pct::Real=-Inf, only_pos:Bool=false, log::Bool=false)\n\nFilter features for each of the classes in a dataset.\n\nArguments:\n\n-`X`: count or data matrix\n-`idents`: class identity for each cell\n-`logfc_threshold`: Limit testing to features which show, on average, at least X-fold difference (log-scale) between the two groups of cells\n-`min_pct`: only test features that are detected in a minimum fraction of `min_pct` cells in either of the two populations\n-`min_diff_pct`: only test features that show a minimum difference in the fraction of detection between the two groups.\n-`only_pos`: only return features with positive log fold-change\n-`log`: the data is in log-scale (default = false)\n\nReturn values:\n\nSelection matrix for each feature and class\n\n\n\n\n\n","category":"function"},{"location":"public/#Severo.purity-Tuple{AbstractArray{T, N} where {T<:Integer, N}, AbstractArray{T, N} where {T<:Integer, N}}","page":"Public","title":"Severo.purity","text":"purity(clusters::IntegerArray, classes::IntegerArray)\n\nCalculates purity between clusters and external clustering (true clusters/classes).\n\nArguments:\n\n- `clusters`: clustering for which to calculate purity\n- `classes`: clustering/classes with which to compare\n\nReturn values:\n\nPurity score in the range [0, 1], with a score of 1 representing a pure/accurate clustering\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_10X-Tuple{AbstractString}","page":"Public","title":"Severo.read_10X","text":"read_10X(dirname::AbstractString; unique_features=true)\n\nRead count matrix from 10X genomics\n\nArguments:\n\ndirname: path to directory containing matrix.mtx, genes.tsv (or features.tsv), and barcodes.tsv from 10X\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_10X_h5-Tuple{AbstractString}","page":"Public","title":"Severo.read_10X_h5","text":"read_10X_h5(fname::AbstractString; dataset::AbstractString=\"/mm10\", unique_features=true)\n\nRead count matrix from 10X CellRanger hdf5 file.\n\nArguments:\n\nfname: path to hdf5 file\ndataset: name of dataset to load (default: \"mm10\")\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_csv-Tuple{AbstractString}","page":"Public","title":"Severo.read_csv","text":"read_csv(fname::AbstractString; unique_features=true)\n\nRead count matrix from CSV\n\nArguments:\n\nfname: path to csv file\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_data-Tuple{AbstractString}","page":"Public","title":"Severo.read_data","text":"read_data(path::AbstractString; kw...)\n\nTries to identify and read a count matrix in any of the supported formats\n\nArguments:\n\nfname: path\nkw: additional keyword arguments are passed on\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_dge-Tuple{AbstractString}","page":"Public","title":"Severo.read_dge","text":"read_dge(fname::AbstractString; unique_features=true)\n\nRead count matrix from digital gene expression (DGE) files\n\nArguments:\n\nfname: path to dge file\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_h5-Tuple{AbstractString}","page":"Public","title":"Severo.read_h5","text":"read_h5(fname::AbstractString; dataset::AbstractString=\"/mm10\", unique_features=true)\n\nRead count matrix from hdf5 file.\n\nArguments:\n\nfname: path to hdf5 file\ndataset: name of dataset to load (default: \"counts\")\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_h5ad-Tuple{AbstractString}","page":"Public","title":"Severo.read_h5ad","text":"read_h5ad(fname::AbstractString, dataset::String=\"/mm10\"; unique_features=true)\n\nRead count matrix from hdf5 file as created by AnnData.py. https://anndata.readthedocs.io/en/latest/fileformat-prose.html\n\nArguments:\n\nfname: path to hdf5 file\nunique_features: should feature names be made unique (default: true)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.read_loom-Tuple{AbstractString}","page":"Public","title":"Severo.read_loom","text":"read_loom(fname::AbstractString; barcode_names::AbstractString=\"CellID\", feature_names::AbstractString=\"Gene\", unique_names::Bool=true, blocksize::Tuple{Int,Int}=(100,100))\n\nRead count matrix from loom format\n\nArguments:\n\nfname: path to loom file\nbarcode_names: key where the observation/cell names are stored.\nfeature_names: key where the variable/feature names are stored.\nunique_names: should feature and barcode names be made unique (default: true)\nblocksize: blocksize to use when reading the matrix (tradeoff between memory and speed)\n\nReturns values:\n\nReturns labeled sparse matrix containing the counts\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.scale_features-Tuple{NamedArrays.NamedArray{T, 2, SparseArrays.SparseMatrixCSC{T, Int64}, DT} where {T, DT}}","page":"Public","title":"Severo.scale_features","text":"scale_features(X::NamedArray{T, 2, SparseMatrixCSC{T, Int64}} ; scale_max=Inf, dtype::Type{<:AbstractFloat})\n\nScale and center a count/data matrix along the cells such that each feature is standardized\n\nArguments:\n\n- `X`: the labelled count/data matrix to scale\n- `scale_max`: maximum value of the scaled data\n\nReturn values:\n\nA centered matrix\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.shared_nearest_neighbours-Tuple{LinearEmbedding, Int64}","page":"Public","title":"Severo.shared_nearest_neighbours","text":"shared_nearest_neighbours(em::LinearEmbedding, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2))\n\nCompute a k-nearest neighbours graph based on an embedding of cells and its Jaccard index.\nThe Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `em`: embedding containing the transformed coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.shared_nearest_neighbours-Tuple{Random.AbstractRNG, LinearEmbedding, Int64}","page":"Public","title":"Severo.shared_nearest_neighbours","text":"shared_nearest_neighbours(rng::AbstractRNG, em::LinearEmbedding, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2))\n\nCompute a k-nearest neighbours graph based on an embedding of cells and its Jaccard index.\nThe Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `rng`: random number generator\n- `em`: embedding containing the transformed coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T","page":"Public","title":"Severo.shared_nearest_neighbours","text":"shared_nearest_neighbours(X::NamedArray{T,2}, k::Int64;\n    dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on coordinates for each cell and its Jaccard index.\nThe Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `X`: a labelled matrix with coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.shared_nearest_neighbours-Union{Tuple{T}, Tuple{Random.AbstractRNG, NamedArrays.NamedMatrix{T, AT, DT} where {AT, DT}, Int64}} where T","page":"Public","title":"Severo.shared_nearest_neighbours","text":"shared_nearest_neighbours(rng::AbstractRNG, X::NamedArray{T,2}, k::Int64; dims=:, metric::SemiMetric=Euclidean(), include_self::Bool=true, ntables::Int64=2*size(X,2)) where T\n\nCompute a k-nearest neighbours graph based on coordinates for each cell and its Jaccard index.\nThe Jaccard index measures similarity between nearest neighbour sets, and is defined as the size of the intersection divided by the size of the union. \"0\" indicating no overlap and \"1\" indicating full overlap.\n\nArguments:\n\n- `rng`: random number generator\n- `X`: a labelled matrix with coordinates for each cell\n- `k`: number of nearest neighbours to find\n- `dims`: which dimensions to use\n- `include_self`: include the cell in its k-nearest neighbours\n- `ntables`: number of tables to use in knn algorithm: controls the precision (higher is more accurate)\n- `prune`: cutoff for the Jaccard index, edges with values below this cutoff are removed from the resulting graph\n\nReturn values:\n\nA shared nearest neighbours graph represented by a sparse matrix. Weights of the edges indicate similarity of the neighbourhoods of the cells as computed with the Jaccard index.\n\n\n\n\n\n","category":"method"},{"location":"public/#Severo.umap","page":"Public","title":"Severo.umap","text":"umap(X::NamedMatrix, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T\n\nPerforms a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates.\n\nFor a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]\n\nArguments:\n\n- `X`: a labelled matrix with coordinates for each cell\n- `ncomponents`: the dimensionality of the embedding\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.\n- `min_dist`: controls how tightly the embedding is allowed compress points together.\n- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding\n- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)\n\nReturn values:\n\nA low-dimensional embedding of the cells\n\n\n\n\n\n","category":"function"},{"location":"public/#Severo.umap-2","page":"Public","title":"Severo.umap","text":"umap(em::LinearEmbedding, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T\n\nPerforms a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates in the linear embedding.\n\nFor a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]\n\nArguments:\n\n- `em`: embedding containing the transformed coordinates for each cell\n- `ncomponents`: the dimensionality of the embedding\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.\n- `min_dist`: controls how tightly the embedding is allowed compress points together.\n- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding\n- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)\n\nReturn values:\n\nA low-dimensional embedding of the cells\n\n\n\n\n\n","category":"function"},{"location":"public/#Severo.umap-Tuple{AbstractMatrix{T} where T, Int64}","page":"Public","title":"Severo.umap","text":"umap(X::AbstractMatrix, ncomponents::Int64=2; dims=:, metric=:cosine, nneighbours::Int=30, min_dist::Real=.3, nepochs::Int=300, kw...) where T\n\nPerforms a Uniform Manifold Approximation and Projection (UMAP) dimensional reduction on the coordinates in the linear embedding.\n\nFor a more in depth discussion of the mathematics underlying UMAP, see the ArXiv paper: [https://arxiv.org/abs/1802.03426]\n\nArguments:\n\n- `X`: an unlabelled matrix with coordinates for each cell\n- `ncomponents`: the dimensionality of the embedding\n- `dims`: which dimensions to use\n- `metric`: distance metric to use\n- `nneighbours`: the number of neighboring points used in local approximations of manifold structure.\n- `min_dist`: controls how tightly the embedding is allowed compress points together.\n- `nepochs`: number of training epochs to be used while optimizing the low dimensional embedding\n- `kw`: additional parameters for the umap algorithm. See [`UMAP.umap`](@ref)\n\nReturn values:\n\nA low-dimensional embedding of the cells\n\n\n\n\n\n","category":"method"},{"location":"#Severo.jl","page":"Home","title":"Severo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Some example usage of the package can be found in the Showcase page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"contributing.md\",\n]\nDepth = 1","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"pbmc.md\",\n    \"performance.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"public.md\", \"internals.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"public.md\"]","category":"page"}]
}
